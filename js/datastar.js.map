{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/dom.ts", "../library/src/utils/text.ts", "../library/src/plugins/core/attributes/computed.ts", "../library/src/plugins/core/attributes/effect.ts", "../library/src/utils/paths.ts", "../library/src/plugins/core/attributes/signals.ts", "../library/src/engine/errors.ts", "../library/src/engine/types.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/plugins/framework/backend/shared.ts", "../library/src/plugins/framework/backend/actions/fetch.ts", "../library/src/plugins/framework/backend/actions/httpMethods.ts", "../library/src/plugins/framework/backend/actions/delete.ts", "../library/src/plugins/framework/backend/actions/get.ts", "../library/src/plugins/framework/backend/actions/patch.ts", "../library/src/plugins/framework/backend/actions/post.ts", "../library/src/plugins/framework/backend/actions/put.ts", "../library/src/utils/view-transitions.ts", "../library/src/plugins/framework/backend/watchers/patchElements.ts", "../library/src/plugins/framework/backend/watchers/patchSignals.ts", "../library/src/plugins/framework/attributes/attr.ts", "../library/src/plugins/framework/attributes/bind.ts", "../library/src/plugins/framework/attributes/class.ts", "../library/src/plugins/framework/attributes/scoped.ts", "../library/src/plugins/framework/attributes/indicator.ts", "../library/src/plugins/framework/attributes/jsonSignals.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/plugins/framework/attributes/on.ts", "../library/src/plugins/framework/attributes/onIntersect.ts", "../library/src/plugins/framework/attributes/onInterval.ts", "../library/src/plugins/framework/attributes/onLoad.ts", "../library/src/plugins/framework/attributes/ref.ts", "../library/src/plugins/framework/attributes/show.ts", "../library/src/plugins/framework/attributes/text.ts", "../library/src/plugins/framework/actions/peek.ts", "../library/src/plugins/framework/actions/setAll.ts", "../library/src/plugins/framework/actions/toggleAll.ts", "../library/src/bundles/datastar.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\"\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\"\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\"\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\"\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\"\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\"\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\"\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\"\n\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\"\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\"\n// #endregion\n\n// #endregion", "import type { HTMLOrSVGElement } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVGElement {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n\nexport function findClosestScoped(el: HTMLOrSVGElement | null): string | null {\n  return (\n    (el?.closest('[data-scoped]') as HTMLOrSVGElement | null)?.dataset\n      .scoped ?? null\n  )\n}\n", "import type { Modifiers } from '../engine/types'\nimport { findClosestScoped } from './dom'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n\nexport function modifyScope(signalName: string, el: HTMLOrSVGElement, mods: Modifiers) {\n  if (mods.has('scoped')) {\n    const scope = findClosestScoped(el)\n    if (scope) {\n      signalName = `${scope}.${signalName}`\n    }\n  }\n  return signalName\n}", "import type { AttributePlugin } from '../../../engine/types'\nimport { modifyCasing } from '../../../utils/text'\n\nexport const Computed: AttributePlugin = {\n  type: 'attribute',\n  name: 'computed',\n  keyReq: 'must',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ key, mods, rx, root, computed }) => {\n    key = modifyCasing(key, mods)\n    root[key] = computed(rx)\n  },\n}\n", "import type { AttributePlugin } from '../../../engine/types'\n\nexport const Effect: AttributePlugin = {\n  type: 'attribute',\n  name: 'effect',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ effect, rx }) => effect(rx),\n}\n", "export const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport function updateLeaves(\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (\n  target: Record<string, any>,\n  paths: Record<string, any>,\n): Record<string, any> => {\n  for (const path in paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), target)\n    obj[lastKey] = paths[path]\n  }\n  return target\n}\n", "import type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing } from '../../../utils/text'\nimport { findClosestScoped } from '../../../utils/dom'\n\nexport const Signals: AttributePlugin = {\n  type: 'attribute',\n  name: 'signals',\n  isExpr: true,\n  onLoad: ({ el, key, mods, rx, merge }) => {\n    const ifMissing = mods.has('ifmissing')\n    const toMerge = rx()\n    const args = { ifMissing }\n\n    if (mods.has('scoped')) {\n      const scope = findClosestScoped(el)\n      merge(scope ? { [scope]: toMerge } : toMerge, args)\n    } else if (key !== '') {\n      merge(pathToObj({}, { [modifyCasing(key, mods)]: toMerge }), args)\n    } else {\n      merge(toMerge, args)\n    }\n  },\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport type { InitContext, RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(ctx: RuntimeContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      // validSignals:\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { DATASTAR } from './consts'\nexport type PluginType = 'attribute' | 'watcher' | 'action'\nexport type Requirement = 'allowed' | 'must' | 'denied' | 'exclusive'\n\n// export type ReactiveNode = Signal | Computed | Effect\n// export type Subscriber = Computed | Effect\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`\nexport type JSONPatch = Record<string, any>\n\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_PATCH_EVENT]: CustomEvent<JSONPatch>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accessible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: 'attribute'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  isExpr?: boolean // If the value is an expression\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the Datastar instance\nexport type WatcherPlugin = {\n  type: 'watcher'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: 'action'\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin // The plugin instance\n  aliasify: (name: string) => string // convert a name the configured alias if any\n  actions: Readonly<ActionPlugins> // All registered actions\n  removals: Map<HTMLOrSVGElement, Map<string, OnRemovalFn>> // Map of cleanup functions by element, keyed by a dataset key-value hash\n  root: Record<string, any> // global signals and computed signals\n  filtered: (opts: SignalFilterOptions, obj?: JSONPatch) => Record<string, any>\n  signal<T>(initialValue?: T | undefined): Signal<T> // creates a signal\n  computed<T>(getter: (previousValue?: T) => T): Computed<T> // creates a computed signal\n  effect(fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n  merge: (patch: any, args?: { ifMissing?: boolean }) => any\n  peek: <T>(fn: () => T) => T // returns the current state of the signal without subscribing\n}\n\nexport type HTMLOrSVGElement = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type ReactiveExpressionFn = <T>(...argsThenDeps: any[]) => T // a reactive expression\n\nexport type RuntimeContext = InitContext & {\n  el: HTMLOrSVGElement // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  rx: ReactiveExpressionFn // function to generate a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n  runtimeErr: (reason: string, metadata?: object) => Error\n  getPath: <T = any>(path: string) => T // get a value from the root or element context\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n\nexport type SignalFilter = string | RegExp\nexport type SignalFilterOptions = {\n  include?: SignalFilter\n  exclude?: SignalFilter\n}\n\nexport type Signal<T = any> = {\n  (): T\n  (value_: T): void\n}\n\nexport type Computed<T = any> = () => T\n\nexport type Effect = () => void\n", "import { findClosestScoped, isHTMLOrSVG } from '../utils/dom'\nimport { isPojo, pathToObj } from '../utils/paths'\nimport { camel, snake } from '../utils/text'\nimport { DATASTAR, DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport type {\n  ActionPlugins,\n  AttributePlugin,\n  Computed,\n  DatastarPlugin,\n  Effect,\n  HTMLOrSVGElement,\n  OnRemovalFn,\n  JSONPatch,\n  RuntimeContext,\n  RuntimeExpressionFunction,\n  Signal,\n  SignalFilterOptions,\n} from './types'\nimport { DATASTAR_SIGNAL_PATCH_EVENT, type SignalFilter } from './types'\n\n/**\n * Custom signals implementation based on Alien Signals\n */\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = any> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = any> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nlet patch: Record<string, any> = {}\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet activeSub: ReactiveNode | undefined\n\nconst signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as () => T\n}\n\nconst computedSymbol = Symbol('computed')\nconst computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as () => T\n  // @ts-ignore\n  c[computedSymbol] = 1\n  return c\n}\n\nconst effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  const prev = setCurrentSub(e)\n  try {\n    e.fn_()\n  } finally {\n    setCurrentSub(prev)\n  }\n  return effectOper.bind(0, e)\n}\n\nconst peek = <T>(fn: () => T): T => {\n  const prev = setCurrentSub(undefined)\n  const result = fn()\n  setCurrentSub(prev)\n  return result\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n\n  if (Object.keys(patch).length) {\n    const oldPatch = patch\n    patch = {}\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail: oldPatch,\n      }),\n    )\n  }\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst setCurrentSub = (sub?: ReactiveNode): ReactiveNode | undefined => {\n  const prevSub = activeSub\n  activeSub = sub\n  return prevSub\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  const prevSub = setCurrentSub(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    setCurrentSub(prevSub)\n    endTracking(c)\n  }\n}\n\nconst updateSignal = (s: AlienSignal, value: any): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    const prev = setCurrentSub(e)\n    startTracking(e)\n    try {\n      ;(e as AlienEffect).fn_()\n    } finally {\n      setCurrentSub(prev)\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | undefined => {\n  if (value.length) {\n    const newValue = value[0]\n    if (s.value_ !== (s.value_ = newValue)) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n    }\n  } else {\n    const value = s.value_\n    if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      if (updateSignal(s, value)) {\n        const subs_ = s.subs_\n        if (subs_) {\n          shallowPropagate(subs_)\n        }\n      }\n    }\n    if (activeSub) {\n      link(s, activeSub)\n    }\n    return value\n  }\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  let nextDep: Link | undefined\n  const recursedCheck = sub.flags_ & (4 satisfies ReactiveFlags.RecursedCheck)\n  if (recursedCheck) {\n    nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n    if (nextDep && nextDep.dep_ === dep) {\n      sub.depsTail_ = nextDep\n      return\n    }\n  }\n  const prevSub = dep.subsTail_\n  if (\n    prevSub &&\n    prevSub.sub_ === sub &&\n    (!recursedCheck || isValidLink(prevSub, sub))\n  ) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub_ = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub_.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub_.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (flags & (3 as ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n      if (\n        !(\n          flags &\n          (60 as\n            | ReactiveFlags.RecursedCheck\n            | ReactiveFlags.Recursed\n            | ReactiveFlags.Dirty\n            | ReactiveFlags.Pending)\n        )\n      ) {\n        sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n      ) {\n        flags = 0 satisfies ReactiveFlags.None\n      } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n        sub.flags_ =\n          (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n          (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n        isValidLink(link, sub)\n      ) {\n        sub.flags_ =\n          flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n        flags &= 1 satisfies ReactiveFlags.Mutable\n      } else {\n        flags = 0 satisfies ReactiveFlags.None\n      }\n\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n\n      if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n        const subSubs = sub.subs_\n        if (subSubs) {\n          link = subSubs\n          if (subSubs.nextSub_) {\n            stack = { value_: next, prev_: stack }\n            next = link.nextSub_\n          }\n          continue\n        }\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n\n  top: while (true) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n\n    let dirty = false\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (depFlags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (depFlags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty && link.nextDep_) {\n      link = link.nextDep_\n      continue\n    }\n\n    while (checkDepth) {\n      --checkDepth\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n      dirty = false\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const nextSub = link.nextSub_\n    const subFlags = sub.flags_\n    if (\n      (subFlags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = subFlags | (16 satisfies ReactiveFlags.Dirty)\n      if (subFlags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n    link = nextSub!\n  } while (link)\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  const depsTail = sub.depsTail_\n  if (depsTail) {\n    let link = sub.deps_!\n    do {\n      if (link === checkLink) {\n        return true\n      }\n      if (link === depsTail) {\n        break\n      }\n      link = link.nextDep_!\n    } while (link)\n  }\n  return false\n}\n\nconst getPath = <T = any>(path: string): T =>\n  path.split('.').reduce((acc, key) => acc[key], root) as T\n\nconst toPojo = (obj: Record<string, any>): Record<string, any> => {\n  const pojo: Record<string, any> = {}\n  for (const key in obj) {\n    let val = obj[key]\n    if (isPojo(val)) {\n      val = toPojo(val)\n    }\n    pojo[key] = val\n  }\n  return pojo\n}\n\nconst deep = (value: Record<string, any>, prefix = ''): Record<string, any> => {\n  const deepObj: Record<string, Signal> = {}\n  for (const key in value) {\n    const s = signal(\n      isPojo(value[key]) ? deep(value[key], `${prefix + key}.`) : value[key],\n    )\n    Object.defineProperty(s, 'name', {\n      get: () => prefix + key,\n    })\n    deepObj[key] = s\n  }\n\n  const keys = signal(true)\n  return new Proxy(deepObj, {\n    get: (_, prop: string) => deepObj[prop]?.(),\n    set: (_, prop: string, newValue) => {\n      const sig = deepObj[prop]\n      if (sig) {\n        const oldValue = peek(sig)\n        if (oldValue !== newValue) {\n          pathToObj(patch, { [prefix + prop]: newValue })\n        }\n        sig(isPojo(newValue) ? deep(newValue, `${prefix + prop}.`) : newValue)\n      } else {\n        if (newValue?.[computedSymbol]) {\n          Object.defineProperty(newValue, 'name', {\n            get: () => prefix + prop,\n          })\n          deepObj[prop] = newValue\n        } else {\n          const s = signal(\n            isPojo(newValue) ? deep(newValue, `${prefix + prop}.`) : newValue,\n          )\n          Object.defineProperty(s, 'name', {\n            get: () => prefix + prop,\n          })\n          deepObj[prop] = s\n        }\n\n        pathToObj(patch, { [prefix + prop]: newValue })\n        keys(!keys())\n      }\n\n      return true\n    },\n    deleteProperty: (_, prop: string) => {\n      delete deepObj[prop]\n\n      pathToObj(patch, { [prefix + prop]: null })\n      keys(!keys())\n\n      return true\n    },\n    ownKeys: () => {\n      keys()\n      return Reflect.ownKeys(deepObj)\n    },\n  })\n}\n\nconst merge = (\n  patch: Record<string, any>,\n  { ifMissing }: { ifMissing?: boolean } = {},\n): void => {\n  batchDepth++\n  for (const key in patch) {\n    if (patch[key] === null) {\n      if (root[key] !== undefined && !ifMissing) {\n        delete root[key]\n      }\n    } else {\n      if (root[key] === undefined || !ifMissing) {\n        mergeInner(patch[key], key, root, ifMissing)\n      }\n    }\n  }\n  !--batchDepth && flush()\n}\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  ifMissing?: boolean,\n): void => {\n  if (isPojo(patch)) {\n    if (!isPojo(targetParent[target])) {\n      targetParent[target] = deep({})\n    }\n    for (const key in patch) {\n      if (patch[key] === null) {\n        if (targetParent[target][key] !== undefined && !ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        if (targetParent[target][key] === undefined || !ifMissing) {\n          mergeInner(patch[key], key, targetParent[target], ifMissing)\n        }\n      }\n    }\n  } else {\n    targetParent[target] = patch\n  }\n}\n\nconst validSignals = (\n  obj: Record<string, any>,\n  prefix: string,\n  paths: string[],\n): void => {\n  for (const key in obj) {\n    paths.push(prefix + key)\n    if (isPojo(obj[key])) {\n      validSignals(obj[key], `${prefix + key}.`, paths)\n    }\n  }\n}\n\nfunction filtered(opts: SignalFilterOptions, obj?: JSONPatch) {\n  const optToRe = (sf: SignalFilter): RegExp =>\n    typeof sf === 'string' ? RegExp(sf) : sf\n  const inc = optToRe(opts.include || /.*/)\n  const exc = optToRe(opts.exclude || /(?!)/)\n\n  // We need to find all valid signal paths in the object\n  const paths: string[] = []\n  validSignals(obj || root, '', paths)\n  const toKeepPaths = paths.filter((path) => inc.test(path) && !exc.test(path))\n\n  // Iterate over the paths to keep and build the masked object\n  const maskedObj: Record<string, any> = {}\n  for (const path of toKeepPaths) {\n    pathToObj(maskedObj, { [path]: getPath(path) })\n  }\n  return maskedObj\n}\n\nconst root: Record<string, any> = deep({})\n\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\n\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\nlet pluginRegexs: RegExp[] = []\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\nfunction aliasify(name: string) {\n  return alias ? `data-${alias}-${name}` : `data-${name}`\n}\n\nconst ctx: RuntimeContext = {\n  aliasify,\n  actions,\n  root,\n  filtered,\n  computed,\n  effect,\n  signal,\n  merge,\n  peek,\n  getPath,\n  removals: new Map<HTMLOrSVGElement, Map<string, OnRemovalFn>>(),\n  mods: new Map(),\n} as unknown as RuntimeContext\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    ctx.plugin = plugin\n    if (plugin.type === 'action') {\n      actions[plugin.name] = plugin\n    } else if (plugin.type === 'attribute') {\n      plugins.push(plugin)\n      plugin.onGlobalInit?.(ctx)\n    } else if (plugin.type === 'watcher') {\n      plugin.onGlobalInit?.(ctx)\n    } else {\n      throw initErr('InvalidPluginType', ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n\n  pluginRegexs = plugins.map((plugin) => RegExp(`^${plugin.name}([A-Z]|_|$)`))\n}\n\nfunction applyEls(els: Iterable<HTMLOrSVGElement>): void {\n  for (const el of els) {\n    for (const key in el.dataset) {\n      applyAttributePlugin(el, key, el.dataset[key]!)\n    }\n  }\n}\n\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root: HTMLOrSVGElement = document.body) {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyEls([root])\n    applyEls(root.querySelectorAll<HTMLOrSVGElement>('*'))\n\n    // Monitor the entire document body or a provided element for changes\n    // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n    if (!mutationObserver) {\n      mutationObserver = new MutationObserver(observe)\n      mutationObserver.observe(root, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n      })\n    }\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLOrSVGElement,\n  attrKey: string,\n  value: string,\n): void {\n  const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey)\n  const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey))\n  if (plugin) {\n    ctx.plugin = plugin\n\n    // Extract the key and modifiers\n    let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/\\_\\_+/)\n\n    const hasKey = !!key\n    if (hasKey) {\n      key = camel(key)\n    }\n    const hasValue = !!value\n\n    // Set up the context for the plugin and element\n    ctx.mods.clear()\n    ctx.key = key\n    ctx.rawKey = rawKey\n    ctx.value = value\n    ctx.el = el\n    ctx.runtimeErr = runtimeErr.bind(0, ctx)\n    ctx.rx = generateReactiveExpression(ctx)\n\n    // Check the requirements\n    const keyReq = plugin.keyReq || 'allowed'\n    if (hasKey) {\n      if (keyReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`)\n      }\n    } else if (keyReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}KeyRequired`)\n    }\n\n    const valReq = plugin.valReq || 'allowed'\n    if (hasValue) {\n      if (valReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`)\n      }\n    } else if (valReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}ValueRequired`)\n    }\n\n    // Check for exclusive requirements\n    if (keyReq === 'exclusive' || valReq === 'exclusive') {\n      if (hasKey && hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`)\n      }\n      if (!hasKey && !hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`)\n      }\n    }\n\n    for (const rawMod of rawModifiers) {\n      const [label, ...mod] = rawMod.split('.')\n      ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n    }\n\n    batchDepth++\n    const cleanup = plugin.onLoad(ctx)\n    !--batchDepth && flush()\n    if (cleanup) {\n      let cleanups = ctx.removals.get(el)\n      if (cleanups) {\n        cleanups.get(rawKey)?.()\n      } else {\n        cleanups = new Map()\n        ctx.removals.set(el, cleanups)\n      }\n      cleanups.set(rawKey, cleanup)\n    }\n  }\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n  const ignore = `[${aliasify('ignore')}]`\n\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          const cleanups = ctx.removals.get(node)\n          // If removals has el, delete it and run all cleanup functions\n          if (ctx.removals.delete(node)) {\n            for (const cleanup of cleanups!.values()) {\n              cleanup()\n            }\n            cleanups!.clear()\n          }\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVGElement>('*'))\n        }\n      }\n    } else if (type === 'attributes') {\n      // If el has a parent with data-ignore, skip it\n      if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n        const key = camel(attributeName!.slice(5))\n        const value = target.getAttribute(attributeName!)\n        if (value === null) {\n          const cleanups = ctx.removals.get(target)\n          if (cleanups) {\n            cleanups.get(key)?.()\n            cleanups.delete(key)\n          }\n        } else {\n          applyAttributePlugin(target, key, value)\n        }\n      }\n    }\n  }\n}\n\nfunction generateReactiveExpression(\n  ctx: RuntimeContext,\n): RuntimeExpressionFunction {\n  let expr = ''\n\n  const attrPlugin = (ctx.plugin as AttributePlugin) || undefined\n\n  // plugin is guaranteed to be an attribute plugin\n  if (attrPlugin?.isExpr) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^\\/])*\\/|\"(\\\\\"|[^\\\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = ctx.value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = ctx.value.trim()\n  }\n\n  // Handle $$ syntax - converts $$signal to $context.signal for context signals\n  expr = expr.replace(\n    // Regex: matches $$ followed by valid signal names (including nested like $$foo.bar)\n    /\\$\\$([a-zA-Z_][\\w.-]*(?:\\.[a-zA-Z_][\\w.-]*)*?)(?=\\s|$|[^\\w.-])/g,\n    // s = captured signal name after $$\n    (_, s) => {\n      const scope = findClosestScoped(ctx.el)\n      return scope ? `$${scope}.${s}` : `$${s}` // if no scope: $signal for global scope\n    },\n  )\n\n  expr = expr.replace(\n    /\\$([a-zA-Z_][\\w.-]*(?:\\.[a-zA-Z_][\\w.-]*)*?)(?=\\s|$|[^\\w.-])/g,\n    (match, signalName) => {\n      // If the signal name ends with a hyphen followed by a $, it's likely two separate signals\n      // So we should not include the trailing hyphen in this signal name\n      if (\n        signalName.endsWith('-') &&\n        match.length < expr.length &&\n        expr[expr.indexOf(match) + match.length] === '$'\n      ) {\n        signalName = signalName.slice(0, -1)\n        const parts = signalName.split('.')\n        return `${parts.reduce((acc: string, part: string) => `${acc}['${part}']`, '$')}-`\n      }\n\n      const parts = signalName.split('.')\n      return parts.reduce(\n        (acc: string, part: string) => `${acc}['${part}']`,\n        '$',\n      )\n    },\n  )\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `dsEscaped${djb2(k)}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  const nameGen = (prefix: string, name: string) => {\n    return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`\n  }\n\n  // Replace any action calls\n  const actionsCalled = new Set<string>()\n  const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n  const actionMatches = [...expr.matchAll(actionsRe)]\n  const actionNames = new Set<string>()\n  const actionFns = new Set<(...args: any[]) => any>()\n  if (actionMatches.length) {\n    const actionPrefix = `${DATASTAR}Act_`\n    for (const match of actionMatches) {\n      const actionName = match[1]\n      const action = actions[actionName]\n      if (!action) {\n        continue\n      }\n      actionsCalled.add(actionName)\n\n      const name = nameGen(actionPrefix, actionName)\n\n      // Add ctx to action calls\n      expr = expr.replace(`@${actionName}(`, `${name}(`)\n      actionNames.add(name)\n      actionFns.add((...args: any[]) => action.fn(ctx, ...args))\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  ctx.fnContent = expr\n\n  try {\n    const fn = Function(\n      'el',\n      '$',\n      ...(attrPlugin?.argNames || []),\n      ...actionNames,\n      expr,\n    )\n    return (...args: any[]) => {\n      try {\n        batchDepth++\n        const result = fn(ctx.el, root, ...args, ...actionFns)\n        !--batchDepth && flush()\n        return result\n      } catch (e: any) {\n        throw ctx.runtimeErr('ExecuteExpression', {\n          error: e.message,\n        })\n      }\n    }\n  } catch (error: any) {\n    throw ctx.runtimeErr('GenerateExpression', {\n      error: error.message,\n    })\n  }\n}\n\nfunction djb2(str: string) {\n  let hash = 5831\n  let i = str.length\n  while (i--) {\n    hash += (hash << 5) + str.charCodeAt(i)\n  }\n  return (hash >>> 0).toString(36)\n}\n", "import { DSP } from '../engine/consts'\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/core/attributes/computed'\nimport { Effect } from '../plugins/core/attributes/effect'\nimport { Signals } from '../plugins/core/attributes/signals'\nimport { apply, load, setAlias } from './engine'\n\nload(Signals, Computed, Effect)\n\nexport { apply, load, setAlias }\n", "import { DATASTAR } from '../../../engine/consts'\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retrying'\n\nexport interface DatastarSSEEvent {\n  type: string\n  el: HTMLOrSVGElement\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_SSE_EVENT]: CustomEvent<DatastarSSEEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_SSE_EVENT,\n    (event: CustomEvent<DatastarSSEEvent>) => {\n      if (event.detail.type === eventType) {\n        const { argsRaw } = event.detail\n        fn(argsRaw)\n      }\n    },\n  )\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DATASTAR,\n  DATASTAR_REQUEST,\n  DefaultSseRetryDurationMs,\n  EventTypePatchElements,\n  EventTypePatchSignals,\n} from '../../../../engine/consts'\nimport type { RuntimeContext, SignalFilter } from '../../../../engine/types'\nimport { kebab } from '../../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  ERROR,\n  FINISHED,\n  RETRIES_FAILED,\n  RETRYING,\n  STARTED,\n} from '../shared'\n\nconst dispatchSSE = (\n  type: string,\n  el: HTMLOrSVGElement,\n  argsRaw: Record<string, string>,\n) =>\n  document.dispatchEvent(\n    new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n      detail: { type, el, argsRaw },\n    }),\n  )\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\ntype ResponseOverrides =\n  | {\n      selector?: string\n      mergeMode?: string\n      useViewTransition?: boolean\n    }\n  | {\n      onlyIfMissing?: boolean\n      mergeMode?: string\n      useViewTransition?: boolean\n    }\n\nexport type FetchArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  abort?: AbortSignal\n  responseOverrides?: ResponseOverrides\n  contentType: 'json' | 'form'\n  includeSignals?: SignalFilter\n  excludeSignals?: SignalFilter\n  selector?: string\n}\n\nexport const sse = async (\n  { el, evt, filtered, runtimeErr }: RuntimeContext,\n  method: string,\n  url: string,\n  {\n    headers: userHeaders = {},\n    contentType = 'json',\n    selector,\n    includeSignals: include = /.*/,\n    excludeSignals: exclude = /(^|\\.)_/,\n    openWhenHidden = false, // will keep the request open even if the document is hidden.\n    retryInterval = DefaultSseRetryDurationMs, // the retry interval in milliseconds\n    retryScaler = 2, // the amount to multiply the retry interval by each time\n    retryMaxWaitMs = 30_000, // the maximum retry interval in milliseconds\n    retryMaxCount = 10, // the maximum number of retries before giving up\n    abort = undefined,\n  }: FetchArgs,\n) => {\n  const action = method.toLowerCase()\n  let cleanupFn = () => {}\n  try {\n    if (!url?.length) {\n      throw runtimeErr('SseNoUrlProvided', { action })\n    }\n\n    const initialHeaders: Record<string, any> = {\n      Accept: 'text/event-stream, text/html, application/json',\n      [DATASTAR_REQUEST]: true,\n    }\n    if (contentType === 'json') {\n      initialHeaders['Content-Type'] = 'application/json'\n    }\n    const headers = Object.assign({}, initialHeaders, userHeaders)\n\n    // We ignore the content-type header if using form data\n    // if missing the boundary will be set automatically\n\n    const req: FetchEventSourceInit = {\n      method,\n      headers,\n      openWhenHidden,\n      retryInterval,\n      retryScaler,\n      retryMaxWaitMs,\n      retryMaxCount,\n      signal: abort,\n      onopen: async (response: Response) => {\n        if (response.status >= 400)\n          dispatchSSE(ERROR, el, { status: response.status.toString() })\n      },\n      onmessage: (evt) => {\n        if (!evt.event.startsWith(DATASTAR)) return\n        const type = evt.event\n        const argsRawLines: Record<string, string[]> = {}\n\n        for (const line of evt.data.split('\\n')) {\n          const i = line.indexOf(' ')\n          const k = line.slice(0, i)\n          const v = line.slice(i + 1)\n          ;(argsRawLines[k] ||= []).push(v)\n        }\n\n        const argsRaw = Object.fromEntries(\n          Object.entries(argsRawLines).map(([k, v]) => [k, v.join('\\n')]),\n        )\n\n        dispatchSSE(type, el, argsRaw)\n      },\n      onerror: (error) => {\n        if (isWrongContent(error)) {\n          // don't retry if the content-type is wrong\n          throw runtimeErr('InvalidContentType', { url })\n        }\n        // do nothing and it will retry\n        if (error) {\n          console.error(error.message)\n          dispatchSSE(RETRYING, el, { message: error.message })\n        }\n      },\n    }\n\n    const urlInstance = new URL(url, window.location.href)\n    const queryParams = new URLSearchParams(urlInstance.search)\n\n    if (contentType === 'json') {\n      const res = JSON.stringify(filtered({ include, exclude }))\n      if (method === 'GET') {\n        queryParams.set(DATASTAR, res)\n      } else {\n        req.body = res\n      }\n    } else if (contentType === 'form') {\n      const formEl = (\n        selector ? document.querySelector(selector) : el.closest('form')\n      ) as HTMLFormElement\n      if (!formEl) {\n        throw runtimeErr(\n          selector ? 'SseFormNotFound' : 'SseClosestFormNotFound',\n          { action, selector },\n        )\n      }\n\n      // Validate the form\n      if (!formEl.checkValidity()) {\n        formEl.reportValidity()\n        cleanupFn()\n        return\n      }\n\n      // Collect the form data\n\n      const formData = new FormData(formEl)\n      let submitter = el as HTMLElement | null\n\n      if (el === formEl && evt instanceof SubmitEvent) {\n        // Get the submitter from the event\n        submitter = evt.submitter\n      } else {\n        // Prevent the form being submitted\n        const preventDefault = (evt: Event) => evt.preventDefault()\n        formEl.addEventListener('submit', preventDefault)\n        cleanupFn = () => formEl.removeEventListener('submit', preventDefault)\n      }\n\n      // Append the value of the form submitter if it is a button with a name\n      if (submitter instanceof HTMLButtonElement) {\n        const name = submitter.getAttribute('name')\n        if (name) formData.append(name, submitter.value)\n      }\n\n      const multipart = formEl.getAttribute('enctype') === 'multipart/form-data'\n      // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n      if (!multipart) {\n        headers['Content-Type'] = 'application/x-www-form-urlencoded'\n      }\n\n      const formParams = new URLSearchParams(formData as any)\n      if (method === 'GET') {\n        for (const [key, value] of formParams) {\n          queryParams.append(key, value)\n        }\n      } else if (multipart) {\n        req.body = formData\n      } else {\n        req.body = formParams\n      }\n    } else {\n      throw runtimeErr('SseInvalidContentType', { action, contentType })\n    }\n\n    dispatchSSE(STARTED, el, {})\n    urlInstance.search = queryParams.toString()\n\n    try {\n      await fetchEventSource(urlInstance.toString(), el, req)\n    } catch (error) {\n      if (!isWrongContent(error)) {\n        throw runtimeErr('SseFetchFailed', { method, url, error })\n      }\n      // exit gracefully and do nothing if the content-type is wrong\n      // this can happen if the client is sending a request\n      // where no response is expected, and they haven't\n      // set the content-type to text/event-stream\n    }\n  } finally {\n    dispatchSSE(FINISHED, el, {})\n    cleanupFn()\n  }\n}\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\n\ninterface EventSourceMessage {\n  id: string\n  event: string\n  data: string\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n): Promise<void> {\n  const reader = stream.getReader()\n  let result = await reader.read()\n  while (!result.done) {\n    onChunk(result.value)\n    result = await reader.read()\n  }\n}\n\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (!buffer) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) lineStart = ++position // skip to next char\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58: // :\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: <explanation>\n          case 13: // \\r\n            discardTrailingNewline = true\n          case 10: // \\n\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) break // Wait for the next arr and then continue parsing\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength)\n      buffer = undefined // we've finished reading it\n    else if (lineStart) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\nfunction getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (!line.length) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? `${message.data}\\n${value}` : value\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = +value\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nconst concat = (a: Uint8Array, b: Uint8Array) => {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nconst newMessage = (): EventSourceMessage => ({\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  data: '',\n  event: '',\n  id: '',\n  retry: undefined,\n})\n\ninterface FetchEventSourceInit extends RequestInit {\n  headers?: Record<string, string>\n  onopen?: (response: Response) => Promise<void>\n  onmessage?: (ev: EventSourceMessage) => void\n  onclose?: () => void\n  onerror?: (err: any) => number | null | undefined | void\n  openWhenHidden?: boolean\n  fetch?: typeof fetch\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  overrides?: ResponseOverrides\n}\n\nfunction fetchEventSource(\n  input: RequestInfo,\n  el: HTMLOrSVGElement,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    overrides,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers: Record<string, string> = {\n      accept: 'text/event-stream',\n      ...inputHeaders,\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) create() // page is now visible again, recreate request.\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch || window.fetch\n    const onopen = inputOnOpen || (() => {})\n\n    let retries = 0\n    let baseRetryInterval = retryInterval\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        // on successful connection, reset the retry logic\n        retries = 0\n        retryInterval = baseRetryInterval\n\n        await onopen(response)\n\n        const dispatchNonSSE = async (\n          dispatchType: string,\n          response: Response,\n          name: string,\n          overrides?: ResponseOverrides,\n          ...argNames: string[]\n        ) => {\n          const argsRaw: Record<string, string> = {\n            [name]: await response.text(),\n          }\n          for (const n of argNames) {\n            let v = response.headers.get(`datastar-${kebab(n)}`)\n            if (overrides) {\n              const o = (overrides as any)[n]\n              if (o) v = typeof o === 'string' ? o : JSON.stringify(o)\n            }\n            if (v) argsRaw[n] = v\n          }\n\n          dispatchSSE(dispatchType, el, argsRaw)\n          dispose()\n        }\n\n        const ct = response.headers.get('Content-Type')\n        if (ct?.includes('text/html'))\n          return await dispatchNonSSE(\n            EventTypePatchElements,\n            response,\n            'elements',\n            overrides,\n            'selector',\n            'mergeMode',\n            'useViewTransition',\n          )\n\n        if (ct?.includes('application/json'))\n          return await dispatchNonSSE(\n            EventTypePatchSignals,\n            response,\n            'signals',\n            overrides,\n            'onlyIfMissing',\n            'mergeMode',\n            'useViewTransition',\n          )\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers['last-event-id'] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  // biome-ignore lint/performance/noDelete: <explanation>\n                  delete headers['last-event-id']\n                }\n              },\n              (retry) => {\n                baseRetryInterval = retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven't aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) || retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n            retryInterval = Math.min(\n              retryInterval * retryScaler,\n              retryMaxWaitMs,\n            ) // exponential backoff\n            if (++retries >= retryMaxCount) {\n              dispatchSSE(RETRIES_FAILED, el, {})\n              // we should not retry anymore:\n              dispose()\n              reject('Max retries reached.') // Max retries reached, check your server or network connection\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "// Factory for creating HTTP method action plugins\nimport type { ActionPlugin } from '../../../../engine/types'\nimport { type FetchArgs, sse } from './fetch'\n\n// Helper to create HTTP method plugins with consistent structure\nexport const createHttpMethod = (\n  name: string,\n  method: string,\n): ActionPlugin => ({\n  type: 'action',\n  name,\n  fn: (ctx, url: string, args: FetchArgs) => sse(ctx, method, url, args),\n})", "// Icon: material-symbols:delete-outline\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const DELETE = createHttpMethod('delete', 'DELETE')\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const GET = createHttpMethod('get', 'GET')\n", "// Icon: fluent:patch-24-filled\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const PATCH = createHttpMethod('patch', 'PATCH')\n", "// Icon: ri:signpost-fill\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const POST = createHttpMethod('post', 'POST')\n", "// Icon: material-symbols:arrows-input\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const PUT = createHttpMethod('put', 'PUT')\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport function modifyViewTransition(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:cloud-download\n// Slug: Patch elements into the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultElementPatchMode,\n  EventTypePatchElements,\n  ElementPatchModeAfter,\n  ElementPatchModeAppend,\n  ElementPatchModeBefore,\n  ElementPatchModeInner,\n  ElementPatchModeOuter,\n  ElementPatchModePrepend,\n  ElementPatchModeRemove,\n  ElementPatchModeReplace,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport type {\n  HTMLOrSVGElement,\n  InitContext,\n  WatcherPlugin,\n} from '../../../../engine/types'\nimport { kebab } from '../../../../utils/text'\nimport { supportsViewTransitions } from '../../../../utils/view-transitions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nlet aliasify: (name: string) => string = (_) => ''\nexport const PatchElements: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchElements,\n  async onGlobalInit(ctx) {\n    aliasify = ctx.aliasify\n    datastarSSEEventWatcher(EventTypePatchElements, (args) =>\n      onPatchElements(ctx, args),\n    )\n  },\n}\n\nconst parser = new DOMParser()\nfunction onPatchElements(\n  ctx: InitContext,\n  {\n    elements,\n    selector,\n    mode = DefaultElementPatchMode,\n    useViewTransition,\n  }: Record<string, string>,\n) {\n  let template: HTMLTemplateElement\n  if (elements.includes('<script')) {\n    const responseDoc = parser.parseFromString(\n      `<body><template>${elements}</template></body>`,\n      'text/html',\n    )\n    template = responseDoc.body.querySelector('template')!\n  } else {\n    template = document.createElement('template')\n    template.innerHTML = elements\n  }\n\n  for (const node of template.content.childNodes) {\n    const type = node.nodeType\n    if (type !== 1) {\n      if (type === 3 && !node.nodeValue!.trim()) {\n        continue\n      }\n      throw initErr('NoElementsFound', ctx)\n    }\n\n    const selectorOrId = selector || `[id=\"${(node as Element).id}\"]`\n    const targets = document.querySelectorAll(selectorOrId)\n    if (!targets.length) {\n      throw initErr('NoTargetsFound', ctx, {\n        selectorOrId,\n      })\n    }\n\n    if (useViewTransition && supportsViewTransitions) {\n      document.startViewTransition(() =>\n        applyToTargets(ctx, mode, node as HTMLOrSVGElement, targets),\n      )\n    } else {\n      applyToTargets(ctx, mode, node as HTMLOrSVGElement, targets)\n    }\n  }\n}\n\nfunction applyToTargets(\n  ctx: InitContext,\n  mode: string,\n  element: HTMLOrSVGElement,\n  capturedTargets: NodeListOf<Element>,\n) {\n  switch (mode) {\n    case ElementPatchModeOuter: {\n      for (const target of capturedTargets) {\n        // Morph the target element with the element\n        morph(target, element)\n      }\n      break\n    }\n    case ElementPatchModeInner:\n      // Replace the contents of the target element with the outer HTML of the response\n      for (const target of capturedTargets) {\n        morph(target, element, 'inner')\n      }\n      break\n    case ElementPatchModeRemove:\n      // Remove the target element\n      for (const target of capturedTargets) {\n        target.remove()\n      }\n      break\n    case ElementPatchModeReplace:\n      // Replace the target element with the response\n      for (const target of capturedTargets) {\n        target.replaceWith(element.cloneNode(true))\n      }\n      break\n\n    case ElementPatchModePrepend:\n      // Insert the response before the first child of the target element\n      for (const target of capturedTargets) {\n        target.prepend(element.cloneNode(true))\n      }\n      break\n    case ElementPatchModeAppend:\n      // Insert the response after the last child of the target element\n      for (const target of capturedTargets) {\n        target.append(element.cloneNode(true))\n      }\n      break\n    case ElementPatchModeBefore:\n      // Insert the response before the target element\n      for (const target of capturedTargets) {\n        target.before(element.cloneNode(true))\n      }\n      break\n    case ElementPatchModeAfter:\n      // Insert the response after the target element\n      for (const target of capturedTargets) {\n        target.after(element.cloneNode(true))\n      }\n      break\n    default:\n      throw initErr('InvalidPatchMode', ctx, { mode })\n  }\n}\n\nconst oldIdTagNameMap = new Map<string, string>()\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nfunction morph(\n  oldElt: Element,\n  newElt: Element,\n  mode: 'inner' | 'outer' = 'outer',\n): void {\n  const ignore = aliasify('ignore-morph')\n  if (\n    (oldElt.hasAttribute(ignore) && newElt.hasAttribute(ignore)) ||\n    oldElt.parentElement?.closest(`[${ignore}]`)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newElt as Element)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of ids that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  oldIdTagNameMap.clear()\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  duplicateIds.clear()\n\n  // Computes a map of nodes to all ids contained within that node (inclusive of the node).\n  // This map can be used to ask if two nodes have intersecting sets of ids,\n  // which allows for a looser definition of \"matching\" than tradition id matching,\n  // and allows child nodes to contribute to a parent nodes matching.\n  // const idMap = new Map<Node, Set<string>>()\n  ctxIdMap.clear()\n\n  populateIdMapWithTree(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    oldIdElements,\n  )\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    normalizedElt,\n    mode === 'outer' ? (oldElt as Node) : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use id sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using id sets, we are able to better match up with content deeper in the DOM.\nfunction morphChildren(\n  oldParent: Element, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n) {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // @ts-ignore\n    const ncId = newChild.id\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(ncId)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by id within the document and pantry, and move it using moveBefore.\n\n      const movedChild = window[ncId] as unknown as Element\n\n      // Removes an element from its ancestors' id maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(ncId)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = document.createElement(\n        (newChild as Element).tagName,\n      )\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nfunction findBestMatch(\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null {\n  let bestMatch = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // max id matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven't yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n    // check for ids we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more ids than the node contains then\n      // we do not have a good candidate for an id match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    // if the current node contains active element, stop looking for better future matches,\n    // because if one is found, this node will be moved to the pantry, re-parenting it and thus losing focus\n    if (cursor.contains(document.activeElement)) break\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\nfunction isSoftMatch(oldNode: Node, newNode: Node): boolean {\n  // ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\n  const oldId = (oldNode as Element).id\n  return (\n    oldNode.nodeType === newNode.nodeType &&\n    (oldNode as Element).tagName === (newNode as Element).tagName &&\n    // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n    // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n    // its not persistent, and new nodes can't have any hidden state.\n    (!oldId || oldId === (newNode as Element).id)\n  )\n}\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nfunction removeNode(node: Node) {\n  // are we going to id set match this later?\n  if (ctxIdMap.has(node)) {\n    // skip callbacks and move to pantry\n    moveBefore(ctxPantry, node, null)\n  } else {\n    // remove for realsies\n    node.parentNode?.removeChild(node)\n  }\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-ignore\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nfunction morphNode(\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node {\n  // syncs the oldNode to the newNode, copying over all attributes and\n  // inner element state from the newNode to the oldNode\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const ignore = aliasify('ignore-morph')\n    if (\n      (oldNode as Element).hasAttribute(ignore) &&\n      (newNode as Element).hasAttribute(ignore)\n    ) {\n      return oldNode\n    }\n\n    const preserveAttrs = (newNode as HTMLElement)\n      .getAttribute(aliasify('preserve-attr'))\n      ?.split(' ')\n\n    const newAttrs = (newNode as Element).attributes\n    for (const { name, value } of newAttrs) {\n      // @ts-ignore\n      if (oldNode[name] !== value && !preserveAttrs?.includes(kebab(name))) {\n        ;(oldNode as Element).setAttribute(name, value)\n      }\n    }\n\n    const oldAttrs = (oldNode as Element).attributes\n    for (let i = oldAttrs.length - 1; i >= 0; i--) {\n      const { name } = oldAttrs[i]\n      // @ts-ignore\n      if (!newAttrs[name] && !preserveAttrs?.includes(kebab(name))) {\n        ;(oldNode as Element).removeAttribute(name)\n      }\n    }\n\n    //  many bothans died to bring us information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n    if (\n      oldNode instanceof HTMLInputElement &&\n      newNode instanceof HTMLInputElement &&\n      newNode.type !== 'file'\n    ) {\n      if (\n        !Object.keys(newNode.dataset).some(\n          String.prototype.startsWith.bind(aliasify('bind').slice(5)),\n        )\n      ) {\n        const newValue = newNode.value\n        if (!newNode.hasAttribute('value')) {\n          oldNode.value = ''\n          oldNode.removeAttribute('value')\n        } else if (oldNode.value !== newValue) {\n          oldNode.setAttribute('value', newValue)\n          oldNode.value = newValue\n        }\n      }\n    } else if (\n      oldNode instanceof HTMLTextAreaElement &&\n      newNode instanceof HTMLTextAreaElement\n    ) {\n      const newValue = newNode.value\n      if (newValue !== oldNode.value) {\n        oldNode.value = newValue\n      }\n      if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n        oldNode.firstChild.nodeValue = newValue\n      }\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  if (!oldNode.isEqualNode(newNode)) {\n    morphChildren(oldNode as Element, newNode as Element)\n  }\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The idSet for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nfunction populateIdMapWithTree(\n  root: Element | null,\n  elements: Element[] | NodeListOf<Element>,\n) {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the id of element to the parent's id set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the id set doesn't exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Patch signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultPatchSignalsOnlyIfMissing,\n  EventTypePatchSignals,\n} from '../../../../engine/consts'\nimport type { WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchSignals: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchSignals,\n  onGlobalInit: (ctx) =>\n    datastarSSEEventWatcher(\n      EventTypePatchSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultPatchSignalsOnlyIfMissing}`,\n      }) =>\n        ctx.merge(jsStrToObject(raw), {\n          ifMissing: isBoolString(onlyIfMissingRaw),\n        }),\n    ),\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:edit-attributes-outline\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: 'attribute',\n  name: 'attr',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, effect, key, rx }) => {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val === null || val === undefined) {\n        el.removeAttribute(key)\n      } else {\n        el.setAttribute(key, val)\n      }\n    }\n    if (key === '') {\n      const observer = new MutationObserver(() => {\n        observer.disconnect()\n        const obj = rx() as Record<string, any>\n        for (const [key, val] of Object.entries(obj)) {\n          syncAttr(key, val)\n        }\n        observer.observe(el, {\n          attributeFilter: Object.keys(obj),\n        })\n      })\n      const cleanup = effect(() => {\n        observer.disconnect()\n        const obj = rx() as Record<string, any>\n        for (const key in obj) {\n          syncAttr(key, obj[key])\n        }\n        observer.observe(el, {\n          attributeFilter: Object.keys(obj),\n        })\n      })\n\n      return () => {\n        observer.disconnect()\n        cleanup()\n      }\n    }\n    // Attributes are always kebab-case\n    const k = kebab(key)\n    const observer = new MutationObserver(() => {\n      observer.disconnect()\n      const value = rx<string>()\n      syncAttr(k, value)\n      observer.observe(el, {\n        attributeFilter: [value],\n      })\n    })\n    const cleanup = effect(() => {\n      observer.disconnect()\n      const value = rx<string>()\n      syncAttr(k, value)\n      observer.observe(el, {\n        attributeFilter: [value],\n      })\n    })\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst textType = /email|password|search|tel|text|url/\nconst numberType = /number|range/\n\nexport const Bind: AttributePlugin = {\n  type: 'attribute',\n  name: 'bind',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  onLoad: ({\n    el,\n    key,\n    mods,\n    value,\n    effect,\n    merge,\n    runtimeErr,\n    aliasify,\n    getPath,\n  }) => {\n    let signalName = key ? modifyCasing(key, mods) : value\n    signalName = modifyScope(signalName, el, mods)\n    \n    const initialSignal = getPath(signalName)\n    const isArraySignal = Array.isArray(initialSignal)\n\n    if (\n      (el instanceof HTMLInputElement && textType.test(el.type)) ||\n      el instanceof HTMLTextAreaElement\n    ) {\n      if (isArraySignal) {\n        // For array signals, determine this input's index based on DOM order\n        const scopedModifier = mods.has('scoped') ? '__scoped' : ''\n        const allBoundInputs = document.querySelectorAll(\n          `[${aliasify('bind')}${scopedModifier}-${key}],[${aliasify('bind')}${scopedModifier}=\"${value}\"]`,\n        )\n\n        let inputIndex = 0\n        const newArray = [...initialSignal]\n        for (const input of allBoundInputs) {\n          if (!newArray[inputIndex]) {\n            newArray[inputIndex] = (input as HTMLInputElement).value\n          }\n\n          if (el === input) {\n            break\n          }\n          inputIndex++\n        }\n        merge(pathToObj({}, { [signalName]: newArray }))\n\n        const syncSignal = () => {\n          const newArray = [...getPath(signalName)]\n          newArray[inputIndex] = el.value\n          merge(pathToObj({}, { [signalName]: newArray }))\n        }\n\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(\n          () => (el.value = getPath(signalName)[inputIndex]),\n        )\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      // Non-array signal handling\n      merge(pathToObj({}, { [signalName]: el.value }), { ifMissing: true })\n\n      const syncSignal = () => merge(pathToObj({}, { [signalName]: el.value }))\n      el.addEventListener('change', syncSignal)\n      el.addEventListener('input', syncSignal)\n\n      const cleanup = effect(() => (el.value = getPath(signalName)))\n\n      return () => {\n        cleanup()\n        el.removeEventListener('change', syncSignal)\n        el.removeEventListener('input', syncSignal)\n      }\n    }\n\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'checkbox') {\n        if (isArraySignal) {\n          // For array signals, determine this input's index based on DOM order\n          const scopedModifier = mods.has('scoped') ? '__scoped' : ''\n          const allBoundInputs = document.querySelectorAll(\n            `[${aliasify('bind')}${scopedModifier}-${key}],[${aliasify('bind')}${scopedModifier}=\"${value}\"]`,\n          )\n\n          let inputIndex = 0\n          const newArray = [...initialSignal]\n          for (const input of allBoundInputs) {\n            if (!newArray[inputIndex]) {\n              const val = input.getAttribute('value')\n              newArray[inputIndex] = val\n                ? (input as HTMLInputElement).checked\n                  ? val\n                  : ''\n                : (input as HTMLInputElement).checked\n            }\n\n            if (el === input) {\n              break\n            }\n            inputIndex++\n          }\n          merge(pathToObj({}, { [signalName]: newArray }))\n\n          const syncSignal = () => {\n            const newArray = [...getPath(signalName)]\n            const val = el.getAttribute('value')\n            newArray[inputIndex] = val ? (el.checked ? val : '') : el.checked\n            merge(pathToObj({}, { [signalName]: newArray }))\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          const cleanup = effect(() => {\n            const val = el.getAttribute('value')\n            el.checked = val\n              ? val === getPath(signalName)[inputIndex]\n              : getPath(signalName)[inputIndex]\n          })\n\n          return () => {\n            cleanup()\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n\n        const val = el.getAttribute('value')\n        merge(\n          pathToObj(\n            {},\n            { [signalName]: val ? (el.checked ? val : '') : el.checked },\n          ),\n        )\n\n        const syncSignal = () => {\n          const val = el.getAttribute('value')\n          merge(\n            pathToObj(\n              {},\n              { [signalName]: val ? (el.checked ? val : '') : el.checked },\n            ),\n          )\n        }\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => {\n          const val = el.getAttribute('value')\n          el.checked = val ? val === getPath(signalName) : getPath(signalName)\n        })\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (el.type === 'radio') {\n        // Set up radio button name attribute if not present\n        if (!el.getAttribute('name')?.length) {\n          el.setAttribute('name', signalName)\n        }\n\n        merge(pathToObj({}, { [signalName]: el.value }), {\n          ifMissing: true,\n        })\n\n        const syncSignal = () =>\n          el.checked && merge(pathToObj({}, { [signalName]: el.value }))\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(\n          () => (el.checked = el.value === getPath(signalName)),\n        )\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (numberType.test(el.type)) {\n        merge(pathToObj({}, { [signalName]: +el.value }), {\n          ifMissing: true,\n        })\n\n        const syncSignal = () =>\n          merge(pathToObj({}, { [signalName]: +el.value }))\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => (el.value = getPath(signalName)))\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (el.type === 'file') {\n        const syncSignal = () => {\n          const files = [...(el.files || [])]\n          const allContents: string[] = []\n          const allMimes: string[] = []\n          const allNames: string[] = []\n          Promise.all(\n            files.map(\n              (f) =>\n                new Promise<void>((resolve) => {\n                  const reader = new FileReader()\n                  reader.onload = () => {\n                    if (typeof reader.result !== 'string') {\n                      throw runtimeErr('InvalidFileResultType', {\n                        resultType: typeof reader.result,\n                      })\n                    }\n                    const match = reader.result.match(dataURIRegex)\n                    if (!match?.groups) {\n                      throw runtimeErr('InvalidDataUri', {\n                        result: reader.result,\n                      })\n                    }\n                    allContents.push(match.groups.contents)\n                    allMimes.push(match.groups.mime)\n                    allNames.push(f.name)\n                  }\n                  reader.onloadend = () => resolve()\n                  reader.readAsDataURL(f)\n                }),\n            ),\n          ).then(() => {\n            merge(\n              pathToObj(\n                {},\n                {\n                  [signalName]: allContents,\n                  [`${signalName}Mimes`]: allMimes,\n                  [`${signalName}Names`]: allNames,\n                },\n              ),\n            )\n          })\n        }\n\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        return () => {\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n      // else unsupported type\n    }\n\n    if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        // Multi-select handling\n        merge(\n          pathToObj(\n            {},\n            {\n              [signalName]: [...el.selectedOptions].map(\n                (option) => option.value,\n              ),\n            },\n          ),\n          {\n            ifMissing: true,\n          },\n        )\n\n        const syncSignal = () =>\n          merge(\n            pathToObj(\n              {},\n              {\n                [signalName]: [...el.selectedOptions].map(\n                  (option) => option.value,\n                ),\n              },\n            ),\n          )\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => {\n          const signalValue: string[] = getPath(signalName)\n          for (const option of el.options) {\n            option.selected = signalValue.includes(option.value)\n          }\n        })\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      // Single-select handling\n      merge(\n        pathToObj(\n          {},\n          {\n            [signalName]: el.value,\n          },\n        ),\n        {\n          ifMissing: true,\n        },\n      )\n\n      const syncSignal = () =>\n        merge(\n          pathToObj(\n            {},\n            {\n              [signalName]: el.value,\n            },\n          ),\n        )\n      el.addEventListener('change', syncSignal)\n      el.addEventListener('input', syncSignal)\n\n      const syncElement = () => (el.value = getPath(signalName))\n      const cleanup = effect(syncElement)\n\n      return () => {\n        cleanup()\n        el.removeEventListener('change', syncSignal)\n        el.removeEventListener('input', syncSignal)\n      }\n    }\n\n    merge(\n      pathToObj(\n        {},\n        {\n          [signalName]: el.getAttribute('value'),\n        },\n      ),\n      { ifMissing: true },\n    )\n\n    const observer = new MutationObserver(() => {\n      merge(\n        pathToObj(\n          {},\n          {\n            [signalName]: el.getAttribute('value'),\n          },\n        ),\n      )\n    })\n    observer.observe(el, {\n      attributeFilter: ['value'],\n    })\n\n    const cleanup = effect(() => el.setAttribute('value', getPath(signalName)))\n\n    return () => {\n      cleanup()\n      observer.disconnect()\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { kebab, modifyCasing } from '../../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: 'attribute',\n  name: 'class',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ key, el, effect, mods, rx }) => {\n    if (key === '') {\n      const observer = new MutationObserver(() => {\n        observer.disconnect()\n        const classes = rx<Record<string, boolean>>()\n        for (const [k, v] of Object.entries(classes)) {\n          const classNames = k.split(/\\s+/)\n          if (v) {\n            el.classList.add(...classNames)\n          } else {\n            el.classList.remove(...classNames)\n          }\n        }\n        observer.observe(el, {\n          attributeFilter: ['class'],\n        })\n      })\n      const cleanup = effect(() => {\n        observer.disconnect()\n        const classes = rx<Record<string, boolean>>()\n        for (const [k, v] of Object.entries(classes)) {\n          const classNames = k.split(/\\s+/)\n          if (v) {\n            el.classList.add(...classNames)\n          } else {\n            el.classList.remove(...classNames)\n          }\n        }\n        observer.observe(el, {\n          attributeFilter: ['class'],\n        })\n      })\n\n      return () => {\n        observer.disconnect()\n        cleanup()\n      }\n    }\n\n    // Default to kebab-case and allow modifying\n    let className = kebab(key)\n    className = modifyCasing(className, mods)\n    const observer = new MutationObserver(() => {\n      observer.disconnect()\n      const shouldInclude = rx<boolean>()\n      if (shouldInclude) {\n        el.classList.add(className)\n      } else {\n        el.classList.remove(className)\n      }\n      observer.observe(el, {\n        attributeFilter: ['class'],\n      })\n    })\n    const cleanup = effect(() => {\n      observer.disconnect()\n      const shouldInclude = rx<boolean>()\n      if (shouldInclude) {\n        el.classList.add(className)\n      } else {\n        el.classList.remove(className)\n      }\n      observer.observe(el, {\n        attributeFilter: ['class'],\n      })\n    })\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: tabler:box\n// Slug: Create a scope for scoped signals\n// Description: This attribute creates a scoped object in signals for scoping data to specific DOM elements.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { modifyScope } from '../../../utils/text'\n\nlet scopedCounter = 0\n\nexport const Scoped: AttributePlugin = {\n  type: 'attribute',\n  name: 'scoped',\n  keyReq: 'denied',\n  onLoad: ({ el, value, mods, merge }) => {\n    let scopedKey =\n      value ||\n      `_${el.closest('[id]')?.id || crypto.randomUUID()}${scopedCounter++}`\n\n    if (el.parentElement) {\n      scopedKey = modifyScope(scopedKey, el.parentElement, mods)\n    }\n\n    // Create the scoped object in signals\n    merge({ [scopedKey]: {} })\n\n    // Return cleanup function that removes the scope\n    return () => {\n      merge({ [scopedKey]: null })\n    }\n  },\n}\n", "// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from '../backend/shared'\n\nexport const Indicator: AttributePlugin = {\n  type: 'attribute',\n  name: 'indicator',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  onLoad: ({ el, key, mods, merge, value }) => {\n    let signalName = key ? modifyCasing(key, mods) : value\n    signalName = modifyScope(signalName, el, mods)\n\n    merge(pathToObj({}, { [signalName]: false }), { ifMissing: true })\n\n    const watcher = ((event: CustomEvent<DatastarSSEEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          merge(pathToObj({}, { [signalName]: true }))\n          break\n        case FINISHED:\n          merge(pathToObj({}, { [signalName]: false }))\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_SSE_EVENT, watcher)\n    return () => {\n      merge(pathToObj({}, { [signalName]: false }))\n      document.removeEventListener(DATASTAR_SSE_EVENT, watcher)\n    }\n  },\n}\n", "// Authors: Ben Croker\n// Icon: tabler:typography\n// Slug: Set the text content of an element to a reactive JSON stringified version of all signals\n// Description: This attribute sets the text content of an element to a reactive JSON stringified version of all signals.\n\nimport type {\n  AttributePlugin,\n  SignalFilterOptions,\n} from '../../../engine/types'\nimport { jsStrToObject } from '../../../utils/text'\n\nexport const JsonSignals: AttributePlugin = {\n  type: 'attribute',\n  name: 'jsonSignals',\n  keyReq: 'denied',\n  onLoad: ({ el, root, value, effect, filtered, mods }) => {\n    const spaces = mods.has('terse') ? 0 : 2\n    const observer = new MutationObserver(() => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(root, null, 2)\n      observer.observe(el, {\n        childList: true,\n      })\n    })\n\n    let filters: SignalFilterOptions = {}\n    if (value.length) {\n      filters = jsStrToObject(value)\n    }\n\n    const cleanup = effect(() => {\n      observer.disconnect()\n      const filteredSignals = filtered(filters)\n      el.textContent = JSON.stringify(filteredSignals, null, spaces)\n      observer.observe(el, {\n        childList: true,\n      })\n    })\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (e) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport function tagFirst(tags?: Set<string>, defaultValue = ''): string {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\nimport { tagHas, tagToMs } from './tags'\n\nexport function delay(\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler {\n  let timer = 0\n  return (...args: any[]) => {\n    timer && clearTimeout(timer)\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      timer && clearTimeout(timer)\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n\nexport function modifyTiming(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrail', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trail', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This plugin adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport {\n  DATASTAR_SIGNAL_PATCH_EVENT,\n  type AttributePlugin,\n} from '../../../engine/types'\nimport { kebab, modifyCasing } from '../../../utils/text'\nimport { modifyTiming } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\nimport { DATASTAR_SSE_EVENT } from '../backend/shared'\n\nexport const On: AttributePlugin = {\n  type: 'attribute',\n  name: 'on',\n  keyReq: 'must',\n  valReq: 'must',\n  argNames: ['evt'],\n  onLoad: (ctx) => {\n    const { el, key, mods, rx } = ctx\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n        // Return if not a trusted event, not a custom event and no `trust` modifier exists\n        if (\n          !(evt.isTrusted || evt instanceof CustomEvent || mods.has('trust'))\n        ) {\n          return\n        }\n        ctx.evt = evt\n      }\n      rx(evt)\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_SSE_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression when an element intersects with the viewport\n// Description: An attribute that runs an expression when an element intersects with the viewport.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { modifyTiming } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\nconst once = new WeakSet<HTMLOrSVGElement>()\n\nexport const OnIntersect: AttributePlugin = {\n  type: 'attribute',\n  name: 'onIntersect',\n  keyReq: 'denied',\n  onLoad: ({ el, mods, rx }) => {\n    let callback = () => rx()\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n}\n", "// Authors: Ben Croker\n// Icon: material-symbols:timer-outline\n// Slug: Runs an expression on an interval\n// Description: This attribute runs an expression on an interval. The interval can be set to a specific duration, and can be set to trigger immediately.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { tagHas, tagToMs } from '../../../utils/tags'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\n\nexport const OnInterval: AttributePlugin = {\n  type: 'attribute',\n  name: 'onInterval',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ mods, rx }) => {\n    let callback = () => rx()\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n}\n", "// Authors: Ben Croker\n// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when the element is loaded\n// Description: This attribute runs an expression when the element is loaded.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { tagToMs } from '../../../utils/tags'\nimport { delay } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\n\nexport const OnLoad: AttributePlugin = {\n  type: 'attribute',\n  name: 'onLoad',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ rx, mods }) => {\n    let callback = () => rx()\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n    }\n    // Delay the callback regardless of whether the modifier is set so that other plugins are processed first.\n    callback = delay(callback, wait)\n    callback()\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: 'attribute',\n  name: 'ref',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  onLoad: ({ key, mods, value, el, merge }) => {\n    let signalName = key ? modifyCasing(key, mods) : value\n    signalName = modifyScope(signalName, el, mods)\n\n    merge(pathToObj({}, { [signalName]: el }))\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport type { AttributePlugin } from '../../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: 'attribute',\n  name: 'show',\n  keyReq: 'denied',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport type { AttributePlugin } from '../../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: 'attribute',\n  name: 'text',\n  keyReq: 'denied',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, { childList: true })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ion:eye\n// Slug: Peek at signals that match the signal path\n// Description: Use a signal or computed signal without subscribing to it.\n\nimport type { ActionPlugin } from '../../../engine/types'\n\nexport const Peek: ActionPlugin = {\n  type: 'action',\n  name: 'peek',\n  fn: ({ peek }, fn: () => any) => {\n    return peek(fn)\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match the signal path\n// Description: Set all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport type { ActionPlugin, RuntimeContext } from '../../../engine/types'\nimport { updateLeaves } from '../../../utils/paths'\n\nexport const SetAll: ActionPlugin = {\n  type: 'action',\n  name: 'setAll',\n  fn: (\n    { merge, filtered }: RuntimeContext,\n    include: string,\n    newValue: any,\n    exclude = /(?!)/,\n  ) => {\n    const masked = filtered({ include, exclude })\n    updateLeaves(masked, () => newValue)\n    merge(masked)\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match the signal path\n// Description: Toggle all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport type { ActionPlugin, RuntimeContext } from '../../../engine/types'\nimport { updateLeaves } from '../../../utils/paths'\n\nexport const ToggleAll: ActionPlugin = {\n  type: 'action',\n  name: 'toggleAll',\n  fn: ({ merge, filtered }: RuntimeContext, include: string) => {\n    const masked = filtered({ include })\n    updateLeaves(masked, (oldValue: any) => !oldValue)\n    merge(masked)\n  },\n}\n", "import { apply, load, setAlias } from '../engine'\nimport { DELETE } from '../plugins/framework/backend/actions/delete'\nimport { GET } from '../plugins/framework/backend/actions/get'\nimport { PATCH } from '../plugins/framework/backend/actions/patch'\nimport { POST } from '../plugins/framework/backend/actions/post'\nimport { PUT } from '../plugins/framework/backend/actions/put'\nimport { PatchElements } from '../plugins/framework/backend/watchers/patchElements'\nimport { PatchSignals } from '../plugins/framework/backend/watchers/patchSignals'\nimport { Attr } from '../plugins/framework/attributes/attr'\nimport { Bind } from '../plugins/framework/attributes/bind'\nimport { Class } from '../plugins/framework/attributes/class'\nimport { Scoped } from '../plugins/framework/attributes/scoped'\nimport { Indicator } from '../plugins/framework/attributes/indicator'\nimport { JsonSignals } from '../plugins/framework/attributes/jsonSignals'\nimport { On } from '../plugins/framework/attributes/on'\nimport { OnIntersect } from '../plugins/framework/attributes/onIntersect'\nimport { OnInterval } from '../plugins/framework/attributes/onInterval'\nimport { OnLoad } from '../plugins/framework/attributes/onLoad'\nimport { Ref } from '../plugins/framework/attributes/ref'\nimport { Show } from '../plugins/framework/attributes/show'\nimport { Text } from '../plugins/framework/attributes/text'\nimport { Peek } from '../plugins/framework/actions/peek'\nimport { SetAll } from '../plugins/framework/actions/setAll'\nimport { ToggleAll } from '../plugins/framework/actions/toggleAll'\n\nload(\n  // Backend\n  GET,\n  POST,\n  PUT,\n  PATCH,\n  DELETE,\n  PatchElements,\n  PatchSignals,\n  // Attributes\n  Attr,\n  Bind,\n  Class,\n  Scoped,\n  Indicator,\n  JsonSignals,\n  On,\n  OnIntersect,\n  OnInterval,\n  OnLoad,\n  Ref,\n  Show,\n  Text,\n  // Actions\n  Peek,\n  SetAll,\n  ToggleAll,\n)\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultSseRetryDurationMs", "DefaultPatchSignalsOnlyIfMissing", "ElementPatchModeOuter", "ElementPatchModeInner", "ElementPatchModeRemove", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "DefaultElementPatchMode", "EventTypePatchElements", "EventTypePatchSignals", "isHTMLOrSVG", "el", "findClosestScoped", "isBoolString", "str", "kebab", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "caseFns", "modifyCasing", "mods", "c", "fn", "modifyScope", "signalName", "el", "scope", "findClosestScoped", "Computed", "key", "mods", "rx", "root", "computed", "modifyCasing", "Effect", "effect", "rx", "isPojo", "obj", "updateLeaves", "fn", "key", "val", "pathToObj", "target", "paths", "path", "keys", "lastKey", "acc", "Signals", "el", "key", "mods", "rx", "merge", "ifMissing", "toMerge", "args", "scope", "findClosestScoped", "pathToObj", "modifyCasing", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "snake", "q", "c", "initErr", "reason", "ctx", "metadata", "errCtx", "dserr", "runtimeErr", "DATASTAR_SIGNAL_PATCH_EVENT", "DATASTAR", "patch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "activeSub", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "prev", "setCurrentSub", "effectOper", "peek", "result", "flush", "run", "oldPatch", "DATASTAR_SIGNAL_PATCH_EVENT", "update", "updateComputed", "updateSignal", "sub", "prevSub", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "shallowPropagate", "newValue", "propagate", "unlink", "prevDep", "depsTail_", "nextDep", "recursedCheck", "subsTail_", "isValidLink", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "subSubs", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "nextSub", "subFlags", "checkLink", "depsTail", "getPath", "path", "acc", "key", "root", "deep", "value", "prefix", "deepObj", "key", "s", "signal", "isPojo", "keys", "_", "prop", "newValue", "sig", "peek", "pathToObj", "patch", "computedSymbol", "merge", "ifMissing", "batchDepth", "root", "mergeInner", "flush", "target", "targetParent", "validSignals", "obj", "paths", "filtered", "opts", "optToRe", "sf", "inc", "exc", "toKeepPaths", "path", "maskedObj", "getPath", "actions", "plugins", "pluginRegexs", "mutationObserver", "alias", "setAlias", "aliasify", "name", "ctx", "computed", "effect", "load", "pluginsToLoad", "plugin", "initErr", "a", "b", "lenDiff", "applyEls", "els", "el", "applyAttributePlugin", "apply", "observe", "attrKey", "rawKey", "camel", "i", "rawModifiers", "hasKey", "hasValue", "runtimeErr", "generateReactiveExpression", "keyReq", "valReq", "rawMod", "label", "mod", "t", "cleanup", "cleanups", "mutations", "ignore", "type", "attributeName", "addedNodes", "removedNodes", "node", "isHTMLOrSVG", "expr", "attrPlugin", "statementRe", "statements", "lastIdx", "last", "scope", "findClosestScoped", "match", "signalName", "acc", "part", "escaped", "escapeRe", "DSP", "DSS", "k", "djb2", "nameGen", "snake", "actionsCalled", "actionsRe", "actionMatches", "actionNames", "actionFns", "actionPrefix", "DATASTAR", "actionName", "action", "args", "v", "fn", "result", "e", "error", "str", "hash", "load", "Signals", "Computed", "Effect", "DATASTAR_SSE_EVENT", "DATASTAR", "STARTED", "FINISHED", "ERROR", "RETRYING", "RETRIES_FAILED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "dispatchSSE", "type", "el", "argsRaw", "DATASTAR_SSE_EVENT", "isWrongContent", "err", "sse", "evt", "filtered", "runtimeErr", "method", "url", "userHeaders", "contentType", "selector", "include", "exclude", "openWhenHidden", "retryInterval", "DefaultSseRetryDurationMs", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "action", "cleanupFn", "initialHeaders", "DATASTAR_REQUEST", "headers", "req", "response", "ERROR", "DATASTAR", "argsRawLines", "line", "i", "k", "v", "error", "RETRYING", "urlInstance", "queryParams", "res", "formEl", "formData", "submitter", "preventDefault", "name", "multipart", "formParams", "key", "value", "STARTED", "fetchEventSource", "FINISHED", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "field", "valueOffset", "retry", "a", "b", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "inputFetch", "overrides", "rest", "resolve", "reject", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "retries", "baseRetryInterval", "dispatchNonSSE", "dispatchType", "argNames", "n", "kebab", "o", "ct", "EventTypePatchElements", "EventTypePatchSignals", "id", "interval", "RETRIES_FAILED", "innerErr", "createHttpMethod", "name", "method", "ctx", "url", "args", "sse", "DELETE", "createHttpMethod", "GET", "createHttpMethod", "PATCH", "createHttpMethod", "POST", "createHttpMethod", "PUT", "createHttpMethod", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "aliasify", "_", "PatchElements", "EventTypePatchElements", "ctx", "datastarSSEEventWatcher", "args", "onPatchElements", "parser", "elements", "selector", "mode", "DefaultElementPatchMode", "useViewTransition", "template", "node", "type", "initErr", "selectorOrId", "targets", "supportsViewTransitions", "applyToTargets", "element", "capturedTargets", "ElementPatchModeOuter", "target", "morph", "ElementPatchModeInner", "ElementPatchModeRemove", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "oldIdTagNameMap", "ctxIdMap", "ctxPersistentIds", "duplicateIds", "ctxPantry", "oldElt", "newElt", "ignore", "normalizedElt", "oldIdElements", "id", "tagName", "newIdElements", "populateIdMapWithTree", "morphChildren", "oldParent", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "cursor", "tempNode", "removeNode", "morphNode", "ncId", "movedChild", "current", "idSet", "moveBefore", "newEmptyChild", "newClonedChild", "startPoint", "nextSibling", "siblingSoftMatchCount", "displaceMatchCount", "nodeMatchCount", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "oldNode", "newNode", "oldId", "preserveAttrs", "newAttrs", "name", "value", "kebab", "oldAttrs", "i", "newValue", "root", "elt", "PatchSignals", "EventTypePatchSignals", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultPatchSignalsOnlyIfMissing", "jsStrToObject", "isBoolString", "Attr", "el", "effect", "key", "rx", "syncAttr", "val", "observer", "obj", "cleanup", "k", "kebab", "value", "dataURIRegex", "textType", "numberType", "Bind", "el", "key", "mods", "value", "effect", "merge", "runtimeErr", "aliasify", "getPath", "signalName", "modifyCasing", "modifyScope", "initialSignal", "isArraySignal", "scopedModifier", "allBoundInputs", "inputIndex", "newArray", "input", "pathToObj", "syncSignal", "cleanup", "val", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "option", "signalValue", "observer", "Class", "key", "el", "effect", "mods", "rx", "observer", "classes", "k", "v", "classNames", "cleanup", "className", "kebab", "modifyCasing", "scopedCounter", "Scoped", "el", "value", "mods", "merge", "scopedKey", "modifyScope", "Indicator", "el", "key", "mods", "merge", "value", "signalName", "modifyCasing", "modifyScope", "pathToObj", "watcher", "event", "type", "elt", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "JsonSignals", "el", "root", "value", "effect", "filtered", "mods", "spaces", "observer", "filters", "jsStrToObject", "cleanup", "filteredSignals", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "throttle", "waiting", "modifyTiming", "mods", "delayArgs", "tagToMs", "debounceArgs", "tagHas", "throttleArgs", "On", "ctx", "el", "key", "mods", "rx", "target", "callback", "evt", "modifyTiming", "modifyViewTransition", "evtListOpts", "cb", "eventName", "kebab", "modifyCasing", "DATASTAR_SSE_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "once", "OnIntersect", "el", "mods", "rx", "callback", "modifyTiming", "modifyViewTransition", "options", "observer", "entries", "entry", "OnInterval", "mods", "rx", "callback", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "OnLoad", "rx", "mods", "callback", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "delay", "Ref", "key", "mods", "value", "el", "merge", "signalName", "modifyCasing", "modifyScope", "pathToObj", "NONE", "DISPLAY", "Show", "el", "effect", "rx", "update", "observer", "cleanup", "Text", "el", "effect", "rx", "update", "observer", "cleanup", "Peek", "peek", "fn", "SetAll", "merge", "filtered", "include", "newValue", "exclude", "masked", "updateLeaves", "ToggleAll", "merge", "filtered", "include", "masked", "updateLeaves", "oldValue", "load", "GET", "POST", "PUT", "PATCH", "DELETE", "PatchElements", "PatchSignals", "Attr", "Bind", "Class", "Scoped", "Indicator", "JsonSignals", "On", "OnIntersect", "OnInterval", "OnLoad", "Ref", "Show", "Text", "Peek", "SetAll", "ToggleAll", "apply"]
}
